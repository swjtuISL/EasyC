# 原理

## 一、基本模型
### 1.容器内存模型
容器是EasyC其最大的特点之一, 其最基本的思想是"交给容器的数据/内存，由容器管理。容器返回的内存, 关联内存同样由容器管理。"
#### 1).关联内存
`关联内存`这一术语仅限于EasyC中，该术语描述了由容器生成的一些内存和容器自身具备关联性，并且容器在释放时，会自动释放关联内存。
```C
String *s = newString("hello");		// 初始化String对象
s->append(s, " ")->append(s, "World");		// 拼接
char * chars = s->toChars(s);		// 以字符形式返回String对象中的字符数据, chars所指向的内存属于关联内存
printf("%s", chars);		// 显示关联内存
freeString(s);		// 释放s, 同时会自动释放关联内存
```
这里`s->toChars(s)`返回的是关联内存, 关联内存的释放不由程序员进行管理，并且程序员也不应该管理，统一交由容器管理释放。并且关联内存具备临时性:
```C
printf("%s", s->toChars(s));
freeString(s);
```
可以即时的打印字符串，并且不需要程序员去释放该字符串的内存。该字符串内存的空间的释放推迟到了字符串释放的时候。<br>
由容器的某个方法生成并返回的内存并不一定是关联内存，非关联内存同样需要由程序员管理。容器返回的哪些是关联内存在API中有详细描述。
#### 2).主题内存
easyc中有一个特殊的容器类：`Object`，这个类被其他所有容器使用，并且是其他容器保存数据的基本单元。Object包装了一个指针，该指针指向实际使用的内存。下图描述了容器，Object和主题内存的关系。
![容器、Object与主题内存的关系](subjectMemory.gif)

我们保存数据时，会将这个数据的地址存放在Object中，再将Object放在容器中。这个地址指向了我们用户使用的数据，因此该地址所指向的内存称为`主题内存`。

#### 3).Object
前一节介绍了主题内存被Object的指针所指向，在这里介绍下Object的作用。Object更为详细的原理和使用请参照后面的[Object原理]()和[ObjectAPI]()
程Object是一个特殊的容器，这个容器仅有其他容器使用，程序员基本没有使用Object的相关场景。Object是对数据的一层抽象，提供了一系列的API方便容器管理内存。以下是Object的结构类型：
```C
struct Object{
	void *item;
	void*(*itemCopy)(void *item);
	void (*itemFree)(void *item);
	String *(*itemToString)(void *item);
};
```
这里的*item就是指向主题内存的指针。很明显，Object中缓存了3个基本方法：itemCopy, itemFree, itemToString.分别管理了item的拷贝，空间释放以及字符串化。

用户再使用容器存放数据的时候，需要指定数据的管理方式，其中包括数据的复制，释放方案，字符串化方案，当这些确定以后，用户就不用自己去管理数据内存的释放了，容器在释放的时候将会自行调用其中每个Object的itemFree以此释放。

因为常用的数据主要是整数，浮点数和字符数组，因此会有这几种类型的Object自动生成函数，避免用户编写冗长的参数。具体会在[Object原理]()中讨论。
### 2.编程模型
C语言的内存泄露时有发生，并且很难控制，但是只需要按照内存模型和编程模型的规范进行编程，就可以提高代码的可维护性、可读性并且可以避免C语言中的内存泄露问题。